{"version":3,"file":"index.js","mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvDA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":[".././uploadImage.js",".././uploadImgbb.js","../../../AppData/Roaming/npm/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../external node-commonjs \"assert\"","../external node-commonjs \"fs\"","../webpack/bootstrap","../webpack/runtime/compat",".././index.js"],"sourcesContent":["const fs = require('fs');\n\nconst uploadImage = async (imagePath, method, apiKey, extraOptions = {}) => {\n  const file = fs.readFileSync(imagePath);\n  if (method === 'imgbb') {\n    const imgbbUploadImage = require('./uploadImgbb');\n    return imgbbUploadImage(file, apiKey, extraOptions);\n  } else {\n    throw new Error('Unsupported method ' + method + '.');\n  }\n};\n\nmodule.exports = uploadImage;\n","/**\n * Upload images to imgbb.\n * @param {string} file a path to the file to upload\n * @param {string} apiKey the API key to access imgbb.com\n * @param {object} extraOptions dictionary with additional options that may be not supported\n *                 by every upload method. imgbb supports name and expiration (in seconds 60-15552000)\n * @see https://api.imgbb.com/ for information about API\n */\nasync function uploadFile(file, apiKey, extraOptions) {\n  const assert = require('assert');\n  assert(apiKey, 'apiKey is required');\n  const axios = require('axios');\n  const FormData = require('form-data');\n  const data = new FormData();\n\n  const base64Image = file.toString('base64');\n  const params = {key: apiKey};\n\n  if ('name' in extraOptions) {\n    console.log('name: ' + extraOptions.name);\n    params.name = extraOptions.name;\n  }\n\n  if ('expiration' in extraOptions) {\n    params.expiration = extraOptions.expiration;\n  }\n\n  data.append('image', base64Image);\n\n  const config = {\n    method: 'post',\n    url: 'https://api.imgbb.com/1/upload',\n    params: params,\n    headers: {\n      ...data.getHeaders(),\n    },\n    data: data,\n  };\n\n  return axios(config)\n      .then(function(response) {\n        if ('expiration' in extraOptions && response.data.data.expiration != extraOptions.expiration) {\n          console.warn(\n              'expiration is not the same. expected: ' + extraOptions.expiration +\n              ' actual: ' + response.data.data.expiration +\n              '\\n Could be caused by reupload of an existing image.');\n        }\n        console.log(JSON.stringify(response.data));\n        return {url: response.data.data.url, expiration: response.data.data.expiration};\n      })\n      .catch(function(error) {\n        console.log(error);\n      });\n}\n\nmodule.exports = uploadFile;\n",null,"module.exports = require(\"assert\");","module.exports = require(\"fs\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","/**\n * A github action that uploads an image and stores its url.\n */\n\nconst core = require('@actions/core');\nconst uploadImage = require('./uploadImage');\nconst assert = require('assert');\n\n/**\n * Runs the action to upload an image.\n * Expected inputs:\n *  path - The path to the image.\n *  uploadMethod - The upload method to use.\n *  apiKey - The API key if the upload method requires it.\n * Output:\n *  url - The url of the image or undefined if the upload failed.\n *  expiration - The expiration of the image or undefined if the upload method does not support it or failed.\n *\n * most @actions toolkit packages have async methods\n */\nasync function run() {\n  try {\n    const paths = core.getMultilineInput('path');\n    const uploadMethod = core.getInput('uploadMethod');\n    const apiKey = core.getInput('apiKey');\n    assert(paths.length > 0, 'Missing mandatory parameter \"paths\"');\n\n    const results = new Map();\n    await Promise.all(\n        paths.map(async (pathToUpload) => {\n          core.info(`Uploding an image ${pathToUpload} to ${uploadMethod}...`);\n\n          const result = await uploadImage(pathToUpload, uploadMethod, apiKey);\n          assert(result, 'There was an error uploading the image.');\n          core.info(`Image uploaded to ${result.url} with expiration ${result.expiration}`);\n          results.set(pathToUpload, result);\n        }),\n    );\n\n    const url = paths\n        .map((pathToUpload) => {\n          return results.get(pathToUpload)?.url;\n        })\n        .join('\\n');\n    core.debug(`Setting output url to: ${url}`);\n    core.setOutput('url', url);\n\n    const expiration = paths\n        .map((pathToUpload) => {\n          return results.get(pathToUpload)?.expiration;\n        })\n        .join('\\n');\n    core.debug(`Setting output expiration to: ${expiration}`);\n    core.setOutput('expiration', expiration);\n  } catch (error) {\n    core.setFailed(error.message);\n  }\n}\n\nrun();\n"],"names":[],"sourceRoot":""}